<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>XP Music Visualizer (Standalone)</title>
    <style>
      /* Basic styling for the XP Music Visualizer */

      html,
      body {
        margin: 0;
        padding: 0;
        height: 100%;
        width: 100%;
        overflow: hidden;
        background: #000;
        font-family: Arial, Helvetica, sans-serif;
        color: #fff;
      }

      #controls {
        position: absolute;
        top: 10px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 10;
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        gap: 8px;
        background: rgba(0, 0, 0, 0.5);
        padding: 8px 16px;
        border-radius: 8px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        backdrop-filter: blur(4px);
      }

      #controls h1 {
        margin: 0;
        font-size: 1.2rem;
        font-weight: normal;
        color: #ffd700;
      }

      /* Tab bar styles */
      #tab-bar {
        display: flex;
        gap: 4px;
      }

      .tab-button {
        background: #444;
        color: #fff;
        border: none;
        padding: 4px 10px;
        border-radius: 4px;
        font-size: 0.8rem;
        cursor: pointer;
        transition: background 0.2s, color 0.2s;
      }

      .tab-button.active,
      .tab-button:hover {
        background: #1e90ff;
      }

      /* Fullscreen button */
      #fullscreen-btn {
        background: transparent;
        color: #fff;
        border: none;
        font-size: 1.2rem;
        cursor: pointer;
        padding: 0 6px;
      }

      #fullscreen-btn:hover {
        color: #ffd700;
      }

      #controls button {
        background: #1e90ff;
        color: #fff;
        border: none;
        padding: 6px 12px;
        border-radius: 4px;
        font-size: 0.9rem;
        cursor: pointer;
        transition: background 0.2s;
      }

      #controls button:hover {
        background: #4682b4;
      }

      #visualizer {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: block;
      }

      .message-overlay {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.6);
        padding: 20px 30px;
        border-radius: 8px;
        text-align: center;
        font-size: 1rem;
        color: #fff;
        z-index: 5;
        pointer-events: none;
      }

      .hidden {
        display: none !important;
      }
    </style>
  </head>
  <body>
    <div id="controls">
      <h1>XP Music Visualizer</h1>
      <div id="tab-bar">
        <button class="tab-button active" data-style="swirl">Swirl</button>
        <button class="tab-button" data-style="burst">Burst</button>
        <button class="tab-button" data-style="spectrum3d">Spectrum 3D</button>
      </div>
      <button id="fullscreen-btn" title="Toggle Fullscreen">â›¶</button>
      <button id="btn-file">Load Audio File</button>
      <input
        type="file"
        id="file-input"
        accept="audio/*"
        style="display: none"
      />
      <button id="btn-mic">Use Microphone</button>
    </div>
    <div id="overlay" class="message-overlay">
      Select an audio file or enable the microphone to start the visualization.
    </div>
    <canvas id="visualizer"></canvas>
    <script>
      /*
       * XP Music Visualizer (Standalone inline script)
       */

      (() => {
        const fileButton = document.getElementById('btn-file');
        const fileInput = document.getElementById('file-input');
        const micButton = document.getElementById('btn-mic');
        const overlay = document.getElementById('overlay');
        const canvas = document.getElementById('visualizer');
        const tabButtons = document.querySelectorAll('.tab-button');
        const fullscreenBtn = document.getElementById('fullscreen-btn');

        let audioCtx;
        let analyser;
        let sourceNode;
        let dataArray;
        let visualizer;
        let microphoneStream;

        // Selected visualization style (swirl, burst, spectrum3d)
        let currentStyle = 'swirl';

        class XPVisualizer {
          constructor(canvasElement, analyserNode, audioContext) {
            this.canvas = canvasElement;
            this.ctx = this.canvas.getContext('2d');
            this.analyser = analyserNode;
            this.audioCtx = audioContext || null;
            this.bufferLength = this.analyser.frequencyBinCount;
            this.dataArray = new Uint8Array(this.bufferLength);
            this.timeMs = 0;
            this.dpr = Math.min(window.devicePixelRatio || 1, 2);
            this.energyEMA = 0;
            this.lastBeatAt = -Infinity;
            this.beatStrength = 0;
            this.resize = this.resize.bind(this);
            this.animate = this.animate.bind(this);
            window.addEventListener('resize', this.resize);
            document.addEventListener('fullscreenchange', this.resize);
            this.resize();
            requestAnimationFrame(this.animate);
            // State for burst visual
            this.scribble = [];
            this.maxScribblePoints = 200;
            this.scribbleAngle = 0;
          }

          resize() {
            // High-DPI aware canvas sizing and scaling
            this.dpr = Math.min(window.devicePixelRatio || 1, 2);
            const cssWidth = window.innerWidth;
            const cssHeight = window.innerHeight;
            this.canvas.style.width = cssWidth + 'px';
            this.canvas.style.height = cssHeight + 'px';
            this.canvas.width = Math.floor(cssWidth * this.dpr);
            this.canvas.height = Math.floor(cssHeight * this.dpr);
            this.ctx.setTransform(this.dpr, 0, 0, this.dpr, 0, 0);
            this.centerX = cssWidth / 2;
            this.centerY = cssHeight / 2;
            // Use the corner distance so circular patterns reach screen corners
            this.maxRadius = Math.hypot(this.centerX, this.centerY);
          }

          animate() {
            // Pull the frequency data from the analyser
            this.analyser.getByteFrequencyData(this.dataArray);
            // Compute audio-synced time in ms
            const nowMs = (this.audioCtx ? this.audioCtx.currentTime : performance.now() / 1000) * 1000;
            this.timeMs = nowMs;
            // Simple beat detection on low frequencies with refractory period
            const len = this.bufferLength;
            const lowBandEnd = Math.max(8, Math.floor(len * 0.15));
            let lowSum = 0;
            for (let i = 0; i < lowBandEnd; i++) lowSum += this.dataArray[i];
            const lowEnergy = lowSum / (255 * lowBandEnd);
            const emaAlpha = 0.12;
            this.energyEMA = this.energyEMA === 0 ? lowEnergy : this.energyEMA * (1 - emaAlpha) + lowEnergy * emaAlpha;
            const threshold = this.energyEMA * 1.35 + 0.02;
            const nowSec = nowMs / 1000;
            if (lowEnergy > threshold && nowSec - this.lastBeatAt > 0.18) {
              this.lastBeatAt = nowSec;
            }
            // Decaying beat strength 0..1 over 250ms
            const beatAge = nowSec - this.lastBeatAt;
            this.beatStrength = Math.max(0, 1 - beatAge / 0.25);
            // Delegate drawing to the appropriate style
            if (currentStyle === 'swirl') {
              this.drawSwirl();
            } else if (currentStyle === 'burst') {
              this.drawBurst();
            } else if (currentStyle === 'spectrum3d') {
              this.drawSpectrum3D();
            }
            requestAnimationFrame(this.animate);
          }

          drawSwirl() {
            const ctx = this.ctx;
            const width = window.innerWidth;
            const height = window.innerHeight;
            // Clear/trail under normal compositing, then switch to additive for strokes
            ctx.globalCompositeOperation = 'source-over';
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.fillRect(0, 0, width, height);
            ctx.globalCompositeOperation = 'lighter';
            const len = this.bufferLength;
            const angleStep = (Math.PI * 2) / len;
            for (let i = 0; i < len; i++) {
              const amp = this.dataArray[i] / 255;
              const beatBoost = 1 + this.beatStrength * 0.25;
              const radius = this.maxRadius * (0.55 + amp * 0.6) * beatBoost;
              const startAngle = i * angleStep + this.timeMs * 0.0003;
              const endAngle = startAngle + angleStep * 0.9;
              const hue = (i / len * 360 + this.timeMs * 0.02) % 360;
              const lightness = 40 + amp * 40;
              ctx.strokeStyle = `hsla(${hue}, 80%, ${lightness}%, ${0.25 + amp * 0.55})`;
              ctx.lineWidth = 1 + amp * 3 + this.beatStrength * 1.2;
              ctx.beginPath();
              ctx.arc(this.centerX, this.centerY, radius, startAngle, endAngle);
              ctx.stroke();
            }
            for (let i = 0; i < len; i++) {
              const amp = this.dataArray[i] / 255;
              const radius = this.maxRadius * (0.45 + amp * 0.7);
              const angle = i * angleStep + this.timeMs * 0.0005;
              const x = this.centerX + Math.cos(angle) * radius;
              const y = this.centerY + Math.sin(angle) * radius;
              const hue = (angle / Math.PI * 180 + this.timeMs * 0.05) % 360;
              const lightness = 50 + amp * 30;
              const sparkle = 0.4 + amp * 0.4 + this.beatStrength * 0.2;
              ctx.fillStyle = `hsla(${hue}, 90%, ${lightness}%, ${sparkle})`;
              ctx.beginPath();
              ctx.arc(x, y, 2 + amp * 4, 0, Math.PI * 2);
              ctx.fill();
            }
          }

          drawBurst() {
            const ctx = this.ctx;
            const width = window.innerWidth;
            const height = window.innerHeight;
            // Clear/trail under normal compositing, then switch to additive for strokes
            ctx.globalCompositeOperation = 'source-over';
            ctx.fillStyle = 'rgba(0, 0, 0, 0.07)';
            ctx.fillRect(0, 0, width, height);
            ctx.globalCompositeOperation = 'lighter';
            const len = this.bufferLength;
            const angleStep = (Math.PI * 2) / len;
            for (let i = 0; i < len; i++) {
              const amp = this.dataArray[i] / 255;
              const angle = i * angleStep + this.timeMs * 0.0002;
              const length = this.maxRadius * (0.35 + amp * 0.8) * (1 + this.beatStrength * 0.3);
              const endX = this.centerX + Math.cos(angle) * length;
              const endY = this.centerY + Math.sin(angle) * length;
              const hue = (i / len * 360 + this.timeMs * 0.05) % 360;
              const lightness = 40 + amp * 40;
              ctx.strokeStyle = `hsla(${hue}, 80%, ${lightness}%, ${0.35 + amp * 0.5 + this.beatStrength * 0.2})`;
              ctx.lineWidth = 1 + amp * 4 + this.beatStrength * 1.5;
              ctx.beginPath();
              ctx.moveTo(this.centerX, this.centerY);
              ctx.lineTo(endX, endY);
              ctx.stroke();
            }
            // Update scribble path based on average amplitude
            const avgAmp = this.dataArray.reduce((a, b) => a + b) / (255 * len);
            this.scribbleAngle += 0.02 + avgAmp * 0.3 + this.beatStrength * 0.05;
            const scribbleRadius = this.maxRadius * 0.4;
            const sx = this.centerX + Math.cos(this.scribbleAngle) * scribbleRadius;
            const sy = this.centerY + Math.sin(this.scribbleAngle) * scribbleRadius;
            this.scribble.push({ x: sx, y: sy });
            if (this.scribble.length > this.maxScribblePoints) {
              this.scribble.shift();
            }
            ctx.strokeStyle = `hsla(${(this.timeMs * 0.05) % 360}, 80%, 70%, ${0.6 + this.beatStrength * 0.3})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let i = 0; i < this.scribble.length; i++) {
              const p = this.scribble[i];
              if (i === 0) {
                ctx.moveTo(p.x, p.y);
              } else {
                ctx.lineTo(p.x, p.y);
              }
            }
            ctx.stroke();
          }

          drawSpectrum3D() {
            const ctx = this.ctx;
            const width = window.innerWidth;
            const height = window.innerHeight;
            // Soft trail
            ctx.globalCompositeOperation = 'source-over';
            ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
            ctx.fillRect(0, 0, width, height);

            const len = this.bufferLength;
            // Horizontal density (columns)
            const barCount = 72;
            const barsPerBin = Math.max(1, Math.floor(len / barCount));
            const barWidth = width / barCount;

            // Geometry
            const depth = barWidth * 0.5; // pseudo extrusion depth
            const margin = Math.max(24, height * 0.06);
            const rowStep = Math.max(8, barWidth * 0.9);
            const halfSpan = (barCount / 2) * (depth * 0.45);

            // Ensure full coverage: add extra rows above and below for the diagonal tilt
            const baseRows = Math.ceil(height / rowStep);
            const extraRows = Math.ceil(halfSpan / rowStep) + 2;
            const rowCount = baseRows + extraRows * 2;

            // Draw back-to-front for proper overlap
            for (let r = rowCount - 1; r >= 0; r--) {
              // Baseline, starting below the bottom to guarantee coverage
              const baseline = height + halfSpan - r * rowStep;
              const rowSlope = depth * 0.45; // consistent skew across row
              for (let i = 0; i < barCount; i++) {
                // Use peak within the bin for more reactivity
                let peak = 0;
                for (let j = 0; j < barsPerBin; j++) {
                  const idx = Math.min(len - 1, i * barsPerBin + j);
                  const v = this.dataArray[idx];
                  if (v > peak) peak = v;
                }
                let amp = peak / 255;
                // Non-linear gain for punchiness
                amp = Math.pow(amp, 1.15);
                // Row modulation and beat emphasis
                const rowMod = 0.9 + 0.2 * Math.sin(this.timeMs * 0.002 + r * 0.7 + i * 0.08);
                const reactivity = 1 + this.beatStrength * 0.8;
                amp *= rowMod * reactivity;

                const barHeight = Math.max(1, rowStep * 1.2 * amp);
                const x = barWidth * i;
                const y = baseline - (i - barCount / 2) * rowSlope;

                const hue = (210 + r * 2.2 + i * 0.8 - amp * 40) % 360;
                const saturation = 88;
                const lightness = 36 + amp * 26 + this.beatStrength * 6;

                // front face
                ctx.fillStyle = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
                ctx.fillRect(x, y - barHeight, barWidth, barHeight);

                // top face (lighter)
                const topLightness = lightness + 15;
                ctx.fillStyle = `hsl(${hue}, ${saturation}%, ${topLightness}%)`;
                ctx.beginPath();
                ctx.moveTo(x, y - barHeight);
                ctx.lineTo(x + depth, y - barHeight - depth * 0.5);
                ctx.lineTo(x + barWidth + depth, y - barHeight - depth * 0.5);
                ctx.lineTo(x + barWidth, y - barHeight);
                ctx.closePath();
                ctx.fill();

                // side face (darker)
                const sideLightness = lightness - 12;
                ctx.fillStyle = `hsl(${hue}, ${saturation}%, ${sideLightness}%)`;
                ctx.beginPath();
                ctx.moveTo(x + barWidth, y - barHeight);
                ctx.lineTo(x + barWidth + depth, y - barHeight - depth * 0.5);
                ctx.lineTo(x + barWidth + depth, y - depth * 0.5);
                ctx.lineTo(x + barWidth, y);
                ctx.closePath();
                ctx.fill();
              }
            }
          }
        }

        async function ensureAudioContext() {
          if (!audioCtx) {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioCtx.createAnalyser();
            analyser.fftSize = 1024;
            analyser.smoothingTimeConstant = 0.5;
            analyser.minDecibels = -100;
            analyser.maxDecibels = -20;
            dataArray = new Uint8Array(analyser.frequencyBinCount);
          }
          // Resume the context on user interaction if suspended
          if (audioCtx.state === 'suspended') {
            await audioCtx.resume();
          }
        }

        function stopCurrentSource() {
          if (sourceNode) {
            try {
              sourceNode.disconnect();
            } catch (e) {
              // Ignore
            }
          }
          if (microphoneStream) {
            microphoneStream.getTracks().forEach((t) => t.stop());
            microphoneStream = null;
          }
        }

        async function loadFile(file) {
          await ensureAudioContext();
          stopCurrentSource();
          const arrayBuffer = await file.arrayBuffer();
          const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
          const bufferSource = audioCtx.createBufferSource();
          bufferSource.buffer = audioBuffer;
          bufferSource.loop = true;
          bufferSource.connect(analyser);
          bufferSource.connect(audioCtx.destination);
          bufferSource.start();
          sourceNode = bufferSource;
          if (!visualizer) {
            visualizer = new XPVisualizer(canvas, analyser, audioCtx);
          }
          overlay.classList.add('hidden');
        }

        async function useMicrophone() {
          await ensureAudioContext();
          stopCurrentSource();
          try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            microphoneStream = stream;
            const micSource = audioCtx.createMediaStreamSource(stream);
            micSource.connect(analyser);
            sourceNode = micSource;
            if (!visualizer) {
              visualizer = new XPVisualizer(canvas, analyser, audioCtx);
            }
            overlay.classList.add('hidden');
          } catch (err) {
            console.error('Microphone access denied:', err);
            overlay.textContent = 'Microphone access was denied. Please allow microphone access or load an audio file.';
            overlay.classList.remove('hidden');
          }
        }

        fileButton.addEventListener('click', () => {
          fileInput.value = '';
          fileInput.click();
        });

        fileInput.addEventListener('change', (e) => {
          const files = e.target.files;
          if (files && files[0]) {
            loadFile(files[0]);
          }
        });

        micButton.addEventListener('click', () => {
          useMicrophone();
        });

        // Tab selection logic
        tabButtons.forEach((btn) => {
          btn.addEventListener('click', () => {
            const style = btn.getAttribute('data-style');
            currentStyle = style;
            // Update active class
            tabButtons.forEach((b) => b.classList.remove('active'));
            btn.classList.add('active');
          });
        });

        // Fullscreen toggle
        fullscreenBtn.addEventListener('click', () => {
          if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen().catch((err) => {
              console.warn('Failed to enter fullscreen:', err);
            });
          } else {
            document.exitFullscreen();
          }
        });
      })();
    </script>
  </body>
  </html>


